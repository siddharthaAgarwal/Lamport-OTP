import sys
import random
import hashlib
import secrets
import base64

class LamportOTP:
    def generate_key(self):
        '''
        Method to generate keys
        :params: None
        :return: private_key, public_key
        '''
        # Initializing private_key and public_key with all zeros
        private_key = [[0 for x in range(256)] for y in range(2)]
        public_key = [[0 for x in range(256)] for y in range(2)]

        # Loop over each number pair in private_key
        for i in range(0,256):
            # Generating bytes for each number pair
            private_key[0][i] = secrets.token_bytes(32)
            private_key[1][i] = secrets.token_bytes(32)

            # Generating hash for public_key from private_key number pairs
            public_key[0][i] = hashlib.sha256(private_key[0][i]).digest()
            public_key[1][i] = hashlib.sha256(private_key[1][i]).digest()

        return private_key, public_key


    def sign_message(self, message, private_key):
        '''
        Method to sign a message
        :params: message - input message in string format
                 private_key - private key generated by generate_key method
        :return: signature
        '''
        # Initializing signature with all zeros
        signature = [0 for x in range(256)]

        # Generating hash (bytes) from message
        h = int.from_bytes(hashlib.sha256(message.encode('utf-8')).digest(), sys.byteorder)
        
        # Creating signature
        for i in range(0,256):
            b = h >> i & 1
            signature[i] = private_key[b][i]

        return signature

    def verify_signature(self, message, signature, public_key):
        '''
        Method to verify signature for a given message
        :params: message - input message in string format
                 signature - signature list of bytes
                 public_key - public key generated by generate_key method
        :return: True or False, based on verification result
        '''
        # Generating hash (bytes) from message
        h = int.from_bytes(hashlib.sha256(message.encode('utf-8')).digest(), sys.byteorder)
        
        # Verifying signature
        for i in range(0,256):
            b = h >> i & 1
            verifier = hashlib.sha256(signature[i]).digest()
            if public_key[b][i] != verifier:
                return False

        return True

    def generate_salt(self, length):
        '''
        Method to generate a random string of give size
        :params: length - length of output salt
        :return: salt - a random string
        '''
        return ''.join([str(random.randint(0, 9)) for i in range(length)])

    
    def get_hex_from_byte(self, byte_array):
        byte_obj = b''.join(byte_array)
        return base64.b64encode(byte_obj).decode('utf-8')

if __name__ == '__main__':
    # Creating Lamport One Time Passaword object
    lamport_otp = LamportOTP()
    # Generating public and private keys
    print("\nGenerating Keys...")
    private_key, public_key = lamport_otp.generate_key()
    print("\nkeys Generated Successfully!")

    # Reading some input message to be signed
    message = input("\nBob's message: ")
    # Generating salt to enhance Lamport OTP
    salt = lamport_otp.generate_salt(16)
    # Adding salt to message
    print('\nAdding salt...')
    message = message + salt

    # Signing message and generating signature
    print('\nSigning message...')
    signature = lamport_otp.sign_message(message, private_key)
    print('\nSignature generated...')
    print(lamport_otp.get_hex_from_byte(signature))

    # Reading message again to verify
    message_input = input("\nmessage to verify: ") + salt

    # Verifying message
    print('\nFetched signature')
    print('\nVerifying message...')
    result = lamport_otp.verify_signature(message_input, signature, public_key)
    print('\nVerification Process Completed!')
    
    # Printing result 
    if result:
        print("\nResult: Authorized!")
    else:
        print("\nResult: Unauthorized!")

